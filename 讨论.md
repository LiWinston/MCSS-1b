我发现最初版本的LTSA模型会导致与Assignment1A十分相似的问题，即分诊台的医患组释放地勤后瞬间被门诊新患者抢占——导致前者不能腾出位置，另外两组人员则均被卡在门诊和分诊台之间的空间，形成死锁。
在1A期间，我就发现了这个问题，当3-8-3的人员数量组合应用时，这几乎必然在模拟序列的某时刻发生，尽管发生的延时并不确定。

死锁发生需要四个为一组的被称为Coffman conditions的充要条件。为了破坏其达成的前提，我的解法克服了“No preemption”——我允许在房间之间过渡态的医患组合暂时地释放服务中的orderlies。例如，在前面描述的场景中，处于门诊和分诊台之间的两组会尝试释放其orderlies，这就允许分诊台中原本面临死锁的患者重新获得离开的机会。至于性能trade off，这种解法或许在模型层面增添了idle机会，但它实际上在实现层面完全可以在原本被阻塞之处的等待环节尝试，并不会显著增大性能开销。（尽管在修改的模型中我没有采取另一种策略，即“仅当下一房间空闲时才出发”，which 确实降低了系统并行性、增大了每个患者的turn around time，且与原题需求和生活实际相背离——医院总不能不允许人们在走廊中同时通过）。

与本modified模型对应的可能解法（Java实现层面）：为orderlies类维护一个静态优先级队列，内含全部工作中的护士及其orderlies分配情况，并以所在位置确定优先级（位置越靠后、距离出院越近的优先级越高）。一方面答允并发的申请时从优先队列头部开始满足，另一方面当任意护士发出请求却发现资源不足时，向后遍历队列，夺取低优先级护士的orderlies并挂起其行动，同时启用回调协程，当此护士依靠抢来的orderlies完成一次转移后旋即将其定向重新分配（归还）给挂起的护士，允许其继续并不再被打断（可以靠一个标志位信号量实现）。

综上所述，问题之本，在于医院的承载能力确实不够，则一定要控制并发强度，否则就需在过程上妥协——采取或超量等待、或抢占之操作。所谓“甘蔗没有两头甜”，“鱼和熊掌不可得兼”所述之理，于斯情景者概莫能外。